Base: &base
  HealthCheckIntervalSeconds: 30
  HealthCheckTimeoutSeconds: 6
  HealthyThresholdCount: 2
  UnhealthyThresholdCount: 3
  TargetGroupAttributes:
    - CookieDuration:
        IBOX_IF:
          - IBOX_MAPNAME.TargetGroupAttributesCookieDurationValue
          - IBOX_IFVALUE
          - Ref('AWS::NoValue')
        Key: 'stickiness.lb_cookie.duration_seconds'
        Value.IBOX_AUTO_PO:
          Description: Sticky Cookie duration in seconds - empty for mapped value - 0 to disable
          CONDITION: get_condition('', 'not_equals', '0', f'{IBOX_MAPNAME}TargetGroupAttributesCookieDurationValue')
        Value: '0'
    - DeregistrationDelay:
        Key: 'deregistration_delay.timeout_seconds'
        Value.IBOX_AUTO_PO: {}
        Value: '30'
    - GroupCookieSticky:
        Key: 'stickiness.enabled'
        Value: If(f'{IBOX_MAPNAME}TargetGroupAttributesCookieDurationValue', 'true', 'false')
  Protocol: HTTP
  VpcId: get_expvalue('VpcId')

global:
  ElasticLoadBalancingV2TargetGroup:
    - IBOX_BASE:
        IBOX_OUTPUT:
          - HealthCheck:
              Value:
                get_subvalue(
                  'Path=${1M},Interval=${2M},Timeout=${3M},Healthy=${4M},Unhealthy=${5M}',
                  [
                    f'{IBOX_MAPNAME}HealthCheckPath',
                    f'{IBOX_MAPNAME}HealthCheckIntervalSeconds',
                    f'{IBOX_MAPNAME}HealthCheckTimeoutSeconds',
                    f'{IBOX_MAPNAME}HealthyThresholdCount',
                    f'{IBOX_MAPNAME}UnhealthyThresholdCount'])
        HealthCheckIntervalSeconds: Ref('AWS::NoValue')
        HealthCheckPath: Ref('AWS::NoValue')
        HealthCheckTimeoutSeconds: Ref('AWS::NoValue')
        HealthyThresholdCount: Ref('AWS::NoValue')
        UnhealthyThresholdCount: Ref('AWS::NoValue')
    - EC2LoadBalancerApplicationExternal:
        IBOX_ENABLED: False
        <<: *base
        Port: 80
    - EC2LoadBalancerApplicationInternal:
        IBOX_ENABLED: False
        <<: *base
        Port: 80
    - EC2LoadBalancerNetworkExternal:
        IBOX_ENABLED: False
        Port: 80
        Protocol: TCP
        VpcId: get_expvalue('VpcId')
    - EC2LoadBalancerNetworkInternal:
        IBOX_ENABLED: False
        Port: 80
        Protocol: TCP
        VpcId: get_expvalue('VpcId')
  ElasticLoadBalancingV2TargetGroupECS:
    - IBOX_BASE:
        <<: *base
        IBOX_OUTPUT:
          - HealthCheck:
              Value:
                get_subvalue(
                  'Path=${1M},Interval=${2M},Timeout=${3M},Healthy=${4M},Unhealthy=${5M}',
                  [
                    f'{IBOX_MAPNAME}HealthCheckPath',
                    f'{IBOX_MAPNAME}HealthCheckIntervalSeconds',
                    f'{IBOX_MAPNAME}HealthCheckTimeoutSeconds',
                    f'{IBOX_MAPNAME}HealthyThresholdCount',
                    f'{IBOX_MAPNAME}UnhealthyThresholdCount'])
          - LoadBalancerApplication:
              Value: get_endvalue('LoadBalancer', nolist=True)
          - ListenerLoadBalancer:
              Value: get_subvalue('HttpPort=${1M},HttpsPort=${2M}', ['ListenerLoadBalancerHttpPort', 'ListenerLoadBalancerHttpsPort'])
        Port: get_endvalue('ContainerDefinitions1ContainerPort')
        TargetType: If('NetworkModeAwsVpc', 'ip', Ref('AWS::NoValue'))
  ElasticLoadBalancingV2TargetGroupALB:
    - IBOX_BASE:
        IBOX_OUTPUT:
          - TargetGroupServiceUnavailable.IBOX_INDEXNAME:
              Value: Ref(f"TargetGroupServiceUnavailable{IBOX_INDEXNAME}")
        Condition: str(f"LoadBalancerApplication{IBOX_INDEXNAME}")
        Targets:
          - ServiceUnavailable:
              Id: get_expvalue(f'LambdaServiceUnavailableArn')
        TargetType: lambda
    - External: {}
    - Internal: {}
